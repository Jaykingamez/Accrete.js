<html>
<head>
	<title>ACCRETE</title>
	<script src="lib/three.min.js"></script>
	<script src="../accrete.js"></script>

	<style>
		body { background: #FFF;overflow:hidden; }
	</style>
</head>
<body>

	<script>
		var height 				= document.body.offsetHeight,
			width 				= document.body.offsetWidth,
			accrete 			= new Accrete(),
			planets 			= accrete.distributePlanets(),

			scene 				= new THREE.Scene(),
			camera 				= new THREE.PerspectiveCamera( 45, width/height, 0.1, 1000 ),
			material 			= new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true }),
			renderer 			= new THREE.WebGLRenderer(),
			meshes 				= [];
		
		camera.position.z = 800;

		scene.add(camera);

		for(var i = 0; i < planets.length; i++) {
			var planet 	= planets[i],
				au 		= Math.log(planet.axis) / Math.log(10),
				rad 	= Math.pow(planet.getEarthMass(), 1/3),
				r 		= rad * (width / 3) / 40,
				x0 		= au * width / 3,
				x 		= x0 + width / 3 - width/2,
				y 		= height / 3 - r;
			
			var geometry = new THREE.SphereGeometry( Math.ceil( r ), 64, 64 );

			var mesh = new THREE.Mesh(geometry, material);

			mesh.position.x = x;
			mesh.position.z = 0;

			meshes.push(mesh);
			scene.add( mesh );
		}

		// var placer = new THREE.Mesh(new THREE.SphereGeometry( 50, 100, 100), material);
		// scene.add(placer);

		document.body.appendChild(renderer.domElement);

		renderer.setSize(document.body.offsetWidth, document.body.offsetHeight);

		function render() {
			window.requestAnimationFrame(render);	
			renderer.render(scene, camera);
		}

		render();

		var lastX 	= 0,
			lastZ 	= camera.position.z,
			rot 	= 0;

		window.onmousewheel = function(e) {
			camera.position.z += e.wheelDelta;
			lastZ = camera.position.z;
		}

		window.onmousedown = function(e) {
			lastX = e.clientX;

			window.onmousemove = function(e) {
				var d = ((lastX - e.clientX) * .02);

				rot += d;
				
				// for(var i = 0; i < meshes.length; i++) {
				// 	// meshes[i].translateX(Math.sin( rot * 180 / Math.PI ));
				// 	// meshes[i].translateZ(Math.sin( (rot * 4) * 180 / Math.PI ));
				// 	meshes[i].rotation = new THREE.Vector3(rot * 180 / Math.PI, 0, rot * Math.PI);
				// }
				
				lastX = e.clientX;

				camera.rotation = new THREE.Vector3(0, rot, 0);
				
				camera.position.x = (width / 2) * Math.sin( rot );
				camera.position.z = (lastZ / 2) * Math.cos( rot );
				
				
				// camera.position.x += d * Math.sin( 1000 * 180 / Math.PI );
				// camera.position.z += d * Math.sin( 1000 * 180 / Math.PI );
			}
		}

		window.onmouseup = function(e) {
			window.onmousemove = undefined;
			lastX = e.clientX;
		}

	</script>	
</body>
</html>
